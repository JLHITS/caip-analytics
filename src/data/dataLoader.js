/**
 * Data Loader for Pre-processed JSON Data
 *
 * This module provides functions to load pre-processed national data
 * that was converted from XLSX to JSON at build time.
 *
 * Benefits:
 * - JSON parsing is 10-20x faster than XLSX parsing
 * - No CPU-intensive parsing at runtime
 * - Smaller bundle size (JSON is more compact)
 */

// Import pre-processed JSON data
// These will be generated by scripts/preprocess-data.js at build time
let appointmentsData = null;
let telephonyData = null;
let onlineConsultationsData = null;

// Cache for loaded data
const dataCache = {
  appointments: null,
  telephony: null,
  onlineConsultations: null,
  workforce: null,
  workforceDefinitions: null,
};

const LFS_PREFIX = 'version https://git-lfs.github.com/spec/v1';

const isHtmlResponse = (text) => {
  const trimmed = text.trim().toLowerCase();
  return trimmed.startsWith('<!doctype') || trimmed.startsWith('<html');
};

const isLfsPointer = (text) => text.trim().startsWith(LFS_PREFIX);

const fetchJsonIfAvailable = async (url) => {
  const response = await fetch(url);
  if (!response.ok) {
    return { unavailable: true, status: response.status };
  }

  const contentType = response.headers.get('content-type') || '';
  if (contentType.includes('application/json')) {
    return { data: await response.json() };
  }

  const text = await response.text();
  if (isLfsPointer(text) || isHtmlResponse(text)) {
    return { unavailable: true };
  }

  try {
    return { data: JSON.parse(text) };
  } catch {
    return { unavailable: true };
  }
};

/**
 * Load appointments data from pre-processed JSON
 * @returns {Promise<Object>} Appointments data by month
 */
export async function loadAppointmentsData() {
  if (dataCache.appointments) {
    return dataCache.appointments;
  }

  const indexResult = await fetchJsonIfAvailable('/data/appointments-index.json');
  if (indexResult?.data) {
    const indexData = indexResult.data;
    const months = Array.isArray(indexData.months) ? indexData.months : Object.keys(indexData.files || {});
    const fileMap = indexData.files || {};

    try {
      const entries = await Promise.all(months.map(async (month) => {
        const relativePath = fileMap[month] || `appointments/${month.replace(/\\s+/g, '_')}.json`;
        const monthResult = await fetchJsonIfAvailable(`/data/${relativePath}`);
        if (!monthResult?.data) {
          throw new Error(`Appointments JSON unavailable for ${month}`);
        }
        return [month, monthResult.data];
      }));

      const data = Object.fromEntries(entries);
      data.metadata = { ...(indexData.metadata || {}), months, files: fileMap };
      dataCache.appointments = data;
      return data;
    } catch {
      return null;
    }
  }

  const legacyResult = await fetchJsonIfAvailable('/data/appointments.json');
  if (legacyResult?.data) {
    dataCache.appointments = legacyResult.data;
    return legacyResult.data;
  }

  return null;
}

/**
 * Load telephony data from pre-processed JSON
 * @returns {Promise<Object>} Telephony data by month
 */
export async function loadTelephonyData() {
  if (dataCache.telephony) {
    return dataCache.telephony;
  }

  const result = await fetchJsonIfAvailable('/data/telephony.json');
  if (result?.data) {
    dataCache.telephony = result.data;
    return result.data;
  }

  return null;
}

/**
 * Load online consultations data from pre-processed JSON
 * @returns {Promise<Object>} Online consultations data by month
 */
export async function loadOnlineConsultationsData() {
  if (dataCache.onlineConsultations) {
    return dataCache.onlineConsultations;
  }

  const result = await fetchJsonIfAvailable('/data/online-consultations.json');
  if (result?.data) {
    dataCache.onlineConsultations = result.data;
    return result.data;
  }

  return null;
}

/**
 * Load workforce data from pre-processed JSON
 * @returns {Promise<Object>} Workforce data by month
 */
export async function loadWorkforceData() {
  if (dataCache.workforce) {
    return dataCache.workforce;
  }

  const indexResult = await fetchJsonIfAvailable('/data/workforce-index.json');
  if (indexResult?.data) {
    const indexData = indexResult.data;
    const months = Array.isArray(indexData.months) ? indexData.months : Object.keys(indexData.files || {});
    const fileMap = indexData.files || {};

    try {
      const entries = await Promise.all(months.map(async (month) => {
        const relativePath = fileMap[month] || `workforce/${month.replace(/\\s+/g, '_')}.json`;
        const monthResult = await fetchJsonIfAvailable(`/data/${relativePath}`);
        if (!monthResult?.data) {
          throw new Error(`Workforce JSON unavailable for ${month}`);
        }
        return [month, monthResult.data];
      }));

      const data = Object.fromEntries(entries);
      data.metadata = { ...(indexData.metadata || {}), months, files: fileMap };
      dataCache.workforce = data;
      return data;
    } catch {
      return null;
    }
  }

  const legacyResult = await fetchJsonIfAvailable('/data/workforce.json');
  if (legacyResult?.data) {
    dataCache.workforce = legacyResult.data;
    return legacyResult.data;
  }

  return null;
}

/**
 * Load workforce data dictionary from pre-processed JSON
 * @returns {Promise<Object>} Workforce definitions
 */
export async function loadWorkforceDefinitions() {
  if (dataCache.workforceDefinitions) {
    return dataCache.workforceDefinitions;
  }

  const result = await fetchJsonIfAvailable('/data/workforce-definitions.json');
  if (result?.data) {
    dataCache.workforceDefinitions = result.data;
    return result.data;
  }

  return null;
}

/**
 * Load all data sources in parallel
 * @returns {Promise<Object>} All data sources
 */
export async function loadAllNationalData() {
  const [appointments, telephony, onlineConsultations, workforce] = await Promise.all([
    loadAppointmentsData(),
    loadTelephonyData(),
    loadOnlineConsultationsData(),
    loadWorkforceData(),
  ]);

  return {
    appointments,
    telephony,
    onlineConsultations,
    workforce,
  };
}

/**
 * Get data for a specific practice across all months
 * @param {string} odsCode - The practice ODS code
 * @param {string} dataType - 'appointments', 'telephony', or 'onlineConsultations'
 * @returns {Promise<Array>} Array of monthly data for the practice
 */
export async function getPracticeData(odsCode, dataType) {
  let data;

  switch (dataType) {
    case 'appointments':
      data = await loadAppointmentsData();
      break;
    case 'telephony':
      data = await loadTelephonyData();
      break;
    case 'onlineConsultations':
      data = await loadOnlineConsultationsData();
      break;
    default:
      throw new Error(`Unknown data type: ${dataType}`);
  }

  const practiceData = [];
  if (!data) return practiceData;

  for (const [month, monthData] of Object.entries(data)) {
    if (month === 'metadata') continue;

    const practices = monthData.practices || monthData;
    const practice = practices.find(p => p.odsCode === odsCode || p.practiceCode === odsCode);

    if (practice) {
      practiceData.push({
        month,
        ...practice,
      });
    }
  }

  return practiceData;
}

/**
 * Search for practices by name or ODS code
 * @param {string} query - Search query
 * @param {string} dataType - Data source to search in
 * @returns {Promise<Array>} Matching practices
 */
export async function searchPractices(query, dataType = 'appointments') {
  let data;

  switch (dataType) {
    case 'appointments':
      data = await loadAppointmentsData();
      break;
    case 'telephony':
      data = await loadTelephonyData();
      break;
    case 'onlineConsultations':
      data = await loadOnlineConsultationsData();
      break;
    default:
      throw new Error(`Unknown data type: ${dataType}`);
  }

  if (!data) return [];
  const queryLower = query.toLowerCase();
  const practicesMap = new Map();

  // Get the latest month's data for searching
  const months = Object.keys(data).filter(k => k !== 'metadata');
  const latestMonth = months[months.length - 1];
  const monthData = data[latestMonth];
  const practices = monthData?.practices || monthData || [];

  for (const practice of practices) {
    const code = practice.odsCode || practice.practiceCode || '';
    const name = practice.practiceName || practice.name || '';

    if (code.toLowerCase().includes(queryLower) || name.toLowerCase().includes(queryLower)) {
      practicesMap.set(code, {
        odsCode: code,
        practiceName: name,
        icb: practice.icb || practice.icbName || '',
        pcn: practice.pcn || practice.pcnName || '',
      });
    }
  }

  return Array.from(practicesMap.values());
}

/**
 * Get available months for a data type
 * @param {string} dataType - 'appointments', 'telephony', or 'onlineConsultations'
 * @returns {Promise<Array>} Array of available months
 */
export async function getAvailableMonths(dataType) {
  let data;

  switch (dataType) {
    case 'appointments':
      data = await loadAppointmentsData();
      break;
    case 'telephony':
      data = await loadTelephonyData();
      break;
    case 'onlineConsultations':
      data = await loadOnlineConsultationsData();
      break;
    default:
      throw new Error(`Unknown data type: ${dataType}`);
  }

  return Object.keys(data).filter(k => k !== 'metadata');
}

/**
 * Clear the data cache (useful for testing or forced refresh)
 */
export function clearDataCache() {
  dataCache.appointments = null;
  dataCache.telephony = null;
  dataCache.onlineConsultations = null;
  dataCache.workforce = null;
  dataCache.workforceDefinitions = null;
}

export default {
  loadAppointmentsData,
  loadTelephonyData,
  loadOnlineConsultationsData,
  loadWorkforceData,
  loadWorkforceDefinitions,
  loadAllNationalData,
  getPracticeData,
  searchPractices,
  getAvailableMonths,
  clearDataCache,
};
